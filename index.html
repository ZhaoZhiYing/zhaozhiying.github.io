<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Zhao Zhiying">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Zhao Zhiying">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Zhao Zhiying">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Zhao Zhiying</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Zhao Zhiying</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/29/AJAX/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhao Zhiying">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhao Zhiying">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/29/AJAX/" itemprop="url">AJAX</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-29T23:08:55+08:00">
                2018-01-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="历史背景"><a href="#历史背景" class="headerlink" title="历史背景"></a>历史背景</h4><h5 id="如何发请求？"><a href="#如何发请求？" class="headerlink" title="如何发请求？"></a>如何发请求？</h5><ul>
<li><code>form</code>可以发<code>get</code> <code>post</code>请求，但是会刷新页面或新开页面</li>
<li><code>a</code>标签可以发<code>get</code>请求，但是会刷新页面或新开页面</li>
<li><code>img</code> 可以发<code>get</code>请求，但是只能以图片的形式展示</li>
<li><code>link</code>可以发<code>get</code>请求，但是只能以 <code>CSS</code> <code>favicon</code> 的形式展示</li>
<li><code>script</code>可以发<code>get</code>请求，但是只能以脚本的形式运行</li>
</ul>
<p>那么问题来了，有没有什么方式可以实现？</p>
<ul>
<li><code>get</code> <code>post</code> <code>put</code> <code>delete</code> 请求都行</li>
<li>想以什么形式展示就以什么形式展示</li>
</ul>
<h5 id="微软的突破"><a href="#微软的突破" class="headerlink" title="微软的突破"></a>微软的突破</h5><p><code>IE 5</code> 率先在 <code>JS</code> 中引入 <code>ActiveX</code> 对象（API），使得 <code>JS</code> 可以直接发起 HTTP 请求。<br>随后 <code>Mozilla</code> <code>Safari</code> <code>Opera</code> 也跟进（抄袭）了，取名 <code>XMLHttpRequest</code>，并被纳入 <code>W3C 规范</code></p>
<h5 id="AJAX诞生"><a href="#AJAX诞生" class="headerlink" title="AJAX诞生"></a><code>AJAX</code>诞生</h5><p>2005年，Jesse James Garrett 发表了一篇在线文章，在这篇文章里介绍了一种技术，叫 <code>AJAX</code>，是对 <code>Asynchronous JavaScript + XML</code> 的简写，译为异步的<code>JavaScript</code>和<code>XML</code>。</p>
<ol>
<li>使用 <code>XMLHttpRequest</code> 发请求</li>
<li>服务器返回 <code>XML</code> 格式的字符串 (<code>XML</code>后来被<code>JSON</code>取代)</li>
<li><code>JS</code> 解析 <code>XML</code>，并更新局部页面</li>
</ol>
<hr>
<h4 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a><code>XMLHttpRequest</code></h4><p>如何使用原生<code>JS</code>来发送<code>AJAX</code>请求？（<code>XMLHttpRequest</code>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//main.js</div><div class="line">myButton.addEventListener(&apos;click&apos;, (e)=&gt;&#123;</div><div class="line"> let request = new XMLHttpRequest()</div><div class="line"> request.onreadystatechange = () =&gt;&#123; </div><div class="line">     if(request.readyState === 4)&#123;</div><div class="line">         console.log(&apos;请求响应完毕&apos;)</div><div class="line">         if(request.status &gt;= 200 &amp;&amp; request.status &lt; 300)&#123;</div><div class="line">             console.log(&apos;请求成功&apos;)</div><div class="line">         &#125;else if(request.status &gt;= 400)&#123;</div><div class="line">             console.log(&apos;请求失败&apos;)</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line"> request.open(&apos;GET&apos;, &apos;/xxx&apos;) // 配置request</div><div class="line"> request.send()</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 后端代码（XML）</div><div class="line">&#125;else if(path === &apos;/xxx&apos;)&#123;</div><div class="line"> response.statusCode = 200</div><div class="line"> response.setHeader(&apos;Content-Type&apos;, &apos;text/XML&apos;)</div><div class="line"> response.write(`</div><div class="line">&lt;note&gt;</div><div class="line">  &lt;to&gt;糖糖&lt;/to&gt;</div><div class="line">  &lt;from&gt;照照&lt;/from&gt;</div><div class="line">   &lt;heading&gt;hellow你好吗&lt;/heading&gt;</div><div class="line">   &lt;body&gt;hellow你好吗衷心感谢珍重再见期待再相逢&lt;/body&gt;</div><div class="line"> &lt;/note&gt;</div><div class="line"> `)</div><div class="line"> response.end()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 后端代码（JSON）</div><div class="line">&#125;else if(path === &apos;/xxx&apos;)&#123;</div><div class="line"> response.statusCode = 200</div><div class="line"> response.setHeader(&apos;Content-Type&apos;, &apos;text/XML&apos;)</div><div class="line"> response.write(`</div><div class="line">  &#123;</div><div class="line">     &quot;note&quot;:&#123;</div><div class="line">        &quot;to&quot;: &quot;糖糖&quot;,</div><div class="line">        &quot;from&quot;: &quot;照照&quot;,</div><div class="line">        &quot;heading&quot;: &quot;哈喽&quot;,</div><div class="line">        &quot;content&quot;: &quot;你好吗&quot;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"> `)</div><div class="line"> response.end()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>readyState</code>的五种状态，重点记住<code>4</code></p>
<p><img src="https://i.loli.net/2018/01/29/5a6eeb46a0ca4.png
"></p>
<h5 id="XML"><a href="#XML" class="headerlink" title="XML"></a><code>XML</code></h5><ul>
<li><p>曾有一段时间，<code>XML</code>是互联网上传输结构化数据的事实标准。</p>
</li>
<li><p>但是<code>XML</code>过于烦琐、冗长。为解决这个问题，涌现了一些方案。直到 2006年，<code>Douglas Crockford</code> 提出了 <code>JSON</code> 语言。</p>
</li>
</ul>
<hr>
<h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a><code>JSON</code></h4><p><code>JSON</code>是<code>JavaScript Object Notation</code>的简称，它是一种表示结构化数据的格式。相比<code>XML</code>，<code>JSON</code>是在<code>JavaScript</code>中读写结构化数据的更好的方式。主要是因为<code>JSON</code>更加简洁。</p>
<h5 id="JSON-与-JavaScript-的关系"><a href="#JSON-与-JavaScript-的关系" class="headerlink" title="JSON 与 JavaScript 的关系"></a><code>JSON</code> 与 <code>JavaScript</code> 的关系</h5><p><code>JSON</code> 和<code>JavaScript</code>是两种不同的语法，<code>JSON</code>参考了<code>JavaScript</code>。</p>
<h5 id="JSON-与-JavaScript-的区别"><a href="#JSON-与-JavaScript-的区别" class="headerlink" title="JSON 与 JavaScript 的区别"></a><code>JSON</code> 与 <code>JavaScript</code> 的区别</h5><p>1.<code>JSON</code>没有<code>function</code>和<code>undefined</code>。<br><br>2.<code>JSON</code>字符串首尾必须使用双引号。<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;Hello world&quot;</div></pre></td></tr></table></figure>
<p>3.与<code>JavaScript</code>的对象字面量相比，<code>JSON</code>对象有两处不同：<br></p>
<ul>
<li><code>JSON</code>没有变量的概念，一个对象以<code>{</code>开始并以<code>}</code>结束。并且没有末尾的分号。</li>
<li><code>JSON</code>中对象的属性名必须加双引号。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&quot;name&quot;: &quot;zhao&quot;, &quot;age&quot;: 18&#125;</div></pre></td></tr></table></figure>
<p>4.<code>JSON</code>的数组也没有变量和分号，一个数组以<code>[</code>开始并以<code>]</code>结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[&quot;name&quot;, 18, true]</div></pre></td></tr></table></figure>
<p>5.<code>JSON</code>中没有原型链。</p>
<hr>
<h4 id="同源策略与CORS跨域"><a href="#同源策略与CORS跨域" class="headerlink" title="同源策略与CORS跨域"></a>同源策略与<code>CORS</code>跨域</h4><h5 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h5><p>只有 协议+端口+域名 一模一样才允许发 <code>AJAX</code> 请求，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">http://baidu.com 可以向 http://www.baidu.com 发 AJAX 请求吗 //no</div><div class="line">http://baidu.com:80 可以向 http://baidu.com:81 发 AJAX 请求吗 //no</div></pre></td></tr></table></figure>
<h5 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a><code>CORS</code></h5><p><code>CORS</code>是跨源资源分享（<code>Cross-Origin Resource Sharing</code>）的缩写，译为跨源资源共享。它是<code>W3C</code>标准，是跨源<code>AJAX</code>请求的根本解决方法。相比<code>JSONP</code>只能发<code>GET</code>请求，<code>CORS</code>允许任何类型的请求。</p>
<ul>
<li>只有 协议+端口+域名 一模一样才允许发 <code>AJAX</code> 请求</li>
<li><code>CORS</code> 可以告诉浏览器，我俩一家的，别阻止他。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 后端代码（JSON）</div><div class="line">&#125;else if(path === &apos;/xxx&apos;)&#123;</div><div class="line"> response.statusCode = 200</div><div class="line"> response.setHeader(&apos;Content-Type&apos;, &apos;text/XML&apos;)</div><div class="line"> response.setHeader(&apos;Access-Control-Allow-Origin&apos;, &apos;http://frank.com:8001&apos;)//CORS</div><div class="line"> response.write(`</div><div class="line">  &#123;</div><div class="line">     &quot;note&quot;:&#123;</div><div class="line">        &quot;to&quot;: &quot;糖糖&quot;,</div><div class="line">        &quot;from&quot;: &quot;照照&quot;,</div><div class="line">        &quot;heading&quot;: &quot;哈喽&quot;,</div><div class="line">        &quot;content&quot;: &quot;你好吗&quot;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"> `)</div><div class="line"> response.end()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>参考：<a href="https://xiedaimala.com/" target="_blank" rel="external">写代码啦</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/25/JSONP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhao Zhiying">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhao Zhiying">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/25/JSONP/" itemprop="url">JSONP</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-25T10:18:42+08:00">
                2018-01-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="数据库是什么？"><a href="#数据库是什么？" class="headerlink" title="数据库是什么？"></a>数据库是什么？</h4><p>只要能长久地存数据，就是数据库</p>
<ol>
<li>文件系统是一种数据库</li>
<li><code>MySQL</code> 是一种数据库</li>
</ol>
<hr>
<h4 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h4><p>它是在1995年，由<code>Netscape</code>提出的一个著名的安全策略，现在所有支持 <code>JavaScript</code> 的浏览器都会使用这个策略。</p>
<p>所谓”同源”指的是”三个相同”：</p>
<ul>
<li>协议相同</li>
<li>域名相同</li>
<li>端口相同</li>
</ul>
<p>如果非同源，共有三种行为受到限制。</p>
<ul>
<li><code>Cookie</code> <code>LocalStorage</code> 和 <code>IndexDB</code> 无法读取。</li>
<li><code>DOM</code> 无法获得。</li>
<li><code>AJAX</code> 请求不能发送。</li>
</ul>
<p>同源政策规定，<code>AJAX</code>请求只能发给同源的网址，否则就报错。有三种方法规避这个限制。</p>
<ul>
<li><code>JSONP</code></li>
<li><code>WebSocket</code></li>
<li><code>CORS</code></li>
</ul>
<h5 id="注意：JSONP的出现先于AJAX，JSONP不属于AJAX。但是jQuery把JSONP归为AJAX的方法里，让很多人误以为JSONP属于AJAX的一种。"><a href="#注意：JSONP的出现先于AJAX，JSONP不属于AJAX。但是jQuery把JSONP归为AJAX的方法里，让很多人误以为JSONP属于AJAX的一种。" class="headerlink" title="注意：JSONP的出现先于AJAX，JSONP不属于AJAX。但是jQuery把JSONP归为AJAX的方法里，让很多人误以为JSONP属于AJAX的一种。"></a>注意：<code>JSONP</code>的出现先于<code>AJAX</code>，<code>JSONP</code>不属于<code>AJAX</code>。但是<code>jQuery</code>把<code>JSONP</code>归为<code>AJAX</code>的方法里，让很多人误以为<code>JSONP</code>属于<code>AJAX</code>的一种。</h5><h5 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a><code>JSONP</code></h5><p>摘自 <a href="https://zh.wikipedia.org/wiki/JSONP" target="_blank" rel="external">维基百科</a></p>
<ul>
<li>由于同源策略，一般来说位于<code>server1.example.com</code>的网页无法与 <code>server2.example.com</code>的服务器沟通。</li>
<li>而<code>HTML</code>的<code>&lt;script&gt;</code>元素是一个例外。利用<code>&lt;script&gt;</code>元素的这个开放策略，网页可以得到从其他来源动态产生的<code>JSON</code>数据，而这种使用模式就是所谓的<code>JSONP</code>。</li>
<li>用<code>JSONP</code>抓到的数据并不是<code>JSON</code>，而是任意的<code>JavaScript</code>，用<code>JavaScript</code>解释器运行而不是用<code>JSON</code>解析器解析。</li>
</ul>
<hr>
<h4 id="局部刷新怎么做？"><a href="#局部刷新怎么做？" class="headerlink" title="局部刷新怎么做？"></a>局部刷新怎么做？</h4><p>有没有想过，不返回<code>HTML</code>，返回<code>JS</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//方案一：用 image 造 get 请求</div><div class="line">button.addEventListener(&apos;click&apos;, (e)=&gt;&#123;</div><div class="line">    let image = document.createElement(&apos;img&apos;)</div><div class="line">    image.src = &apos;/pay&apos;</div><div class="line">    image.onload = function()&#123; // 状态码是 200~299 则表示成功</div><div class="line">        alert(&apos;成功&apos;)</div><div class="line">    &#125;</div><div class="line">    image.onload = function()&#123; // 状态码大于等于 400 则表示失败</div><div class="line">        alert(&apos;失败&apos;)</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//方案二：用 script 造 get 请求</div><div class="line">button.addEventListener(&apos;click&apos;, (e)=&gt;&#123;</div><div class="line">    let script = document.createElement(&apos;script&apos;)</div><div class="line">    script.src = &apos;/pay&apos;</div><div class="line">    document.body.appendChild(script)</div><div class="line">    script.onload = function(e)&#123; // 状态码是 200~299 则表示成功</div><div class="line">        e.currentTarget.remove()</div><div class="line">    &#125;</div><div class="line">    script.onload = function(e)&#123; // 状态码大于等于 400 则表示失败</div><div class="line">        e.currentTarget.remove()</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//后端代码</div><div class="line">...</div><div class="line">if (path === &apos;/pay&apos;)&#123;</div><div class="line">    let amount = fs.readFileSync(&apos;./db&apos;, &apos;utf8&apos;)</div><div class="line">    amount -= 1</div><div class="line">    fs.writeFileSync(&apos;./db&apos;, amount)</div><div class="line">    response.setHeader(&apos;Content-Type&apos;, &apos;application/javascript&apos;)</div><div class="line">    response.write(&apos;amount.innerText = &apos; + amount)</div><div class="line">    response.end()</div><div class="line">&#125;</div><div class="line">...</div></pre></td></tr></table></figure>
<p>无刷新，局部更新页面内容，这种技术叫做<code>SRJ</code> - <code>Server Rendered JavaScript</code></p>
<hr>
<h4 id="JSONP-1"><a href="#JSONP-1" class="headerlink" title="JSONP"></a><code>JSONP</code></h4><h5 id="什么是-JSONP"><a href="#什么是-JSONP" class="headerlink" title="什么是 JSONP?"></a>什么是 <code>JSONP</code>?</h5><ul>
<li><code>JSONP</code>是<code>JSON with Padding</code>的简称。</li>
<li><code>JSONP</code> 是服务器与客户端跨源通信的常用方法。是指动态创建 <code>script</code>，并调用我给你的<code>callback</code>技术。详细过程如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">* 请求方：frank.com 的前端程序员（浏览器）</div><div class="line">* 响应方：jack.com 的后端程序员（服务器）</div><div class="line"></div><div class="line">1. 请求方创建 script，src 指向响应方，同时传一个查询参数 ?callbackName=xxx ，xxx 是随机数。</div><div class="line">2. 响应方根据查询参数 callbackName ，构造形式如 xxx.call(undefined, &apos;你要的数据&apos;) 这样的响应。</div><div class="line">3. 浏览器接收到响应，就会执行 xxx.call(undefined, &apos;你要的数据&apos;)。 </div><div class="line">4. 那么请求方就知道了他要的数据。</div></pre></td></tr></table></figure>
<p>约定</p>
<ul>
<li><code>callbackName</code> 约定叫做 <code>callback</code> </li>
<li><code>xxx</code> 是随机数，比如：<code>&#39;frank&#39;+ parseInt(Math.random() * 100000,10)</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">//方案三：JSONP</div><div class="line">button.addEventListener(&apos;click&apos;, (e)=&gt;&#123;</div><div class="line">    let script = document.createElement(&apos;script&apos;)</div><div class="line">    let functionName = &apos;frank&apos;+ parseInt(Math.random()*10000000 ,10)</div><div class="line">    window[functionName] = function()&#123;  // 每次请求之前搞出一个随机的函数</div><div class="line">        amount.innerText = amount.innerText - 0 - 1</div><div class="line">    &#125;</div><div class="line">    script.src = &apos;/pay?callback=&apos; + functionName</div><div class="line">    document.body.appendChild(script)</div><div class="line">    script.onload = function(e)&#123; // 状态码是 200~299 则表示成功</div><div class="line">        e.currentTarget.remove()</div><div class="line">        delete window[functionName] // 请求完了就干掉这个随机函数</div><div class="line">    &#125;</div><div class="line">    script.onload = function(e)&#123; // 状态码大于等于 400 则表示失败</div><div class="line">        e.currentTarget.remove()</div><div class="line">        delete window[functionName] // 请求完了就干掉这个随机函数</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"> //上面代码用 jQuery 写</div><div class="line"> $.ajax(&#123;</div><div class="line"> url: &quot;http://jack.com:8002/pay&quot;,</div><div class="line"> dataType: &quot;jsonp&quot;,</div><div class="line">	 success: function( response ) &#123;</div><div class="line">	     if(response === &apos;success&apos;)&#123;</div><div class="line">	    	 amount.innerText = amount.innerText - 1</div><div class="line">	     &#125;</div><div class="line">	 &#125;</div><div class="line"> &#125;)</div><div class="line"> $.jsonp()</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//后端代码</div><div class="line">...</div><div class="line">if (path === &apos;/pay&apos;)&#123;</div><div class="line">    let amount = fs.readFileSync(&apos;./db&apos;, &apos;utf8&apos;)</div><div class="line">    amount -= 1</div><div class="line">    fs.writeFileSync(&apos;./db&apos;, amount)</div><div class="line">    let callbackName = query.callback</div><div class="line">    response.setHeader(&apos;Content-Type&apos;, &apos;application/javascript&apos;)</div><div class="line">    response.write(`</div><div class="line">        $&#123;callbackName&#125;.call(undefined, &apos;success&apos;)</div><div class="line">    `)</div><div class="line">    response.end()</div><div class="line">&#125;</div><div class="line">...</div></pre></td></tr></table></figure>
<h5 id="JSONP-为什么不支持-POST-请求？"><a href="#JSONP-为什么不支持-POST-请求？" class="headerlink" title="JSONP 为什么不支持 POST 请求？"></a><code>JSONP</code> 为什么不支持 <code>POST</code> 请求？</h5><p><code>JSONP</code>是通过动态创建 <code>script</code> 实现的，<code>script</code>标签的<code>src</code>属性没有跨域的限制。如果用<code>post</code>，就会检查是否跨域。</p>
<hr>
<p>参考：</p>
<p><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="external">阮一峰 - 浏览器同源政策及其规避方法</a></p>
<p><a href="https://xiedaimala.com/" target="_blank" rel="external">写代码啦</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/23/ new 做了什么？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhao Zhiying">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhao Zhiying">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/23/ new 做了什么？/" itemprop="url">new 做了什么？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-23T15:27:32+08:00">
                2018-01-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇博客会先从「创建对象模式」的变化过程讲起，由此能深刻理解构造函数中的<code>new</code>到底做了些什么？</p>
<hr>
<h4 id="「Object构造函数」"><a href="#「Object构造函数」" class="headerlink" title="「Object构造函数」"></a>「<code>Object</code>构造函数」</h4><p>创建自定义对象的最简单方式就是创建一个<code>Object</code>的实例，然后再为它添加属性和方法。如下：</p>
<pre><code>var person = new Object()
person.name = &apos;zhao&apos;;
person.walk = function(){
    console.log(&apos;走一步的代码&apos;)
} 
</code></pre><h5 id="转折点：早期的-JS开发人员-经常使用这个模式创建对象。后来，「对象字面量」凭着用更少代码的优势，成为创建对象的首选模式。"><a href="#转折点：早期的-JS开发人员-经常使用这个模式创建对象。后来，「对象字面量」凭着用更少代码的优势，成为创建对象的首选模式。" class="headerlink" title="转折点：早期的 JS开发人员 经常使用这个模式创建对象。后来，「对象字面量」凭着用更少代码的优势，成为创建对象的首选模式。"></a>转折点：早期的 JS开发人员 经常使用这个模式创建对象。后来，「对象字面量」凭着用更少代码的优势，成为创建对象的首选模式。</h5><hr>
<h4 id="「对象字面量」"><a href="#「对象字面量」" class="headerlink" title="「对象字面量」"></a>「对象字面量」</h4><pre><code>var person = {
    name: &apos;zhao&apos;,
    walk: function(){
        console.log(&apos;走一步的代码&apos;)
    }
}
</code></pre><h5 id="转折点：「Object构造函数」和「对象字面量」都可以创建单个对象，但是这两个方法有个缺点，当使用同一个接口创建多个对象时，会产生大量的重复代码。于是，「工厂模式」应运而生。"><a href="#转折点：「Object构造函数」和「对象字面量」都可以创建单个对象，但是这两个方法有个缺点，当使用同一个接口创建多个对象时，会产生大量的重复代码。于是，「工厂模式」应运而生。" class="headerlink" title="转折点：「Object构造函数」和「对象字面量」都可以创建单个对象，但是这两个方法有个缺点，当使用同一个接口创建多个对象时，会产生大量的重复代码。于是，「工厂模式」应运而生。"></a>转折点：「<code>Object</code>构造函数」和「对象字面量」都可以创建单个对象，但是这两个方法有个缺点，当使用同一个接口创建多个对象时，会产生大量的重复代码。于是，「工厂模式」应运而生。</h5><hr>
<h4 id="「工厂模式」"><a href="#「工厂模式」" class="headerlink" title="「工厂模式」"></a>「工厂模式」</h4><p>「工厂模式」是指用函数来封装以特定接口创建对象的细节。</p>
<pre><code>function Foo(name, city){
    this.name = name;
    this.city = city;
    this.walk = function walk(){
        console.log(&apos;走一步的代码&apos;)
    }
    return Foo
}

var human1 = Foo({name:&apos;zhao&apos;, city: &apos;beijing&apos;})
var human2 = Foo({name:&apos;zhao&apos;, city: &apos;beijing&apos;})
</code></pre><h5 id="转折点：「工厂模式」解决了创建同一个接口多个对象的问题，但每次都会返回一个包含多个属性的对象。重点是不能识别一个对象的类型。"><a href="#转折点：「工厂模式」解决了创建同一个接口多个对象的问题，但每次都会返回一个包含多个属性的对象。重点是不能识别一个对象的类型。" class="headerlink" title="转折点：「工厂模式」解决了创建同一个接口多个对象的问题，但每次都会返回一个包含多个属性的对象。重点是不能识别一个对象的类型。"></a>转折点：「工厂模式」解决了创建同一个接口多个对象的问题，但每次都会返回一个包含多个属性的对象。重点是不能识别一个对象的类型。</h5><hr>
<h4 id="「构造函数」"><a href="#「构造函数」" class="headerlink" title="「构造函数」"></a>「构造函数」</h4><p>随着<code>JavaScript</code>的发展，出现了一种新的模式 ——「构造函数」。</p>
<ul>
<li>构造函数可以创建特定类型的对象。</li>
<li>此外，也可以创建自定义的构造函数，从而自定义对象类型的属性和方法。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function Foo(name, city)&#123;</div><div class="line">	this.name = name;</div><div class="line">	this.city = city;</div><div class="line">	this.walk = function walk()&#123;</div><div class="line">    	console.log(&apos;走一步的代码&apos;)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var human1 = new Foo(&#123;name:&apos;zhao&apos;, city: &apos;beijing&apos;&#125;)</div><div class="line">var human2 = new Foo(&#123;name:&apos;zhao&apos;, city: &apos;beijing&apos;&#125;)</div></pre></td></tr></table></figure>
<p>上面代码中，我们看到，与「工厂模式」的不同之处：</p>
<ol>
<li>没有显式地创建对象</li>
<li>直接将属性和方法赋给了<code>this</code>对象</li>
<li>没有<code>return</code>语句</li>
<li>函数名首字母是大写<code>F</code>。按照惯例，构造函数始终以大写字母开头，主要是为了区别其他函数。</li>
<li>用了<code>new</code>操作符创建新实例。</li>
</ol>
<h4 id="重点来了，new在这里到底干了些什么？"><a href="#重点来了，new在这里到底干了些什么？" class="headerlink" title="重点来了，new在这里到底干了些什么？"></a>重点来了，<code>new</code>在这里到底干了些什么？</h4><p>要创建构造函数的新实例，必须使用 <code>new</code> 操作符。以这种方式调用构造函数会经历以下步骤：</p>
<ol>
<li>创建一个新对象，这个对象的类型是<code>object</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var human1 = &#123;&#125;</div></pre></td></tr></table></figure>
<ol>
<li>将构造函数的作用域赋给新对象（因此<code>this</code>就指向了这个新对象）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">human1.__proto__ = Foo.prototype</div></pre></td></tr></table></figure>
<ol>
<li>执行构造函数中的代码（为这个新对象添加属性）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Foo.call(human1)</div></pre></td></tr></table></figure>
<ol>
<li>返回新对象</li>
</ol>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/19/this 到底是什么？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhao Zhiying">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhao Zhiying">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/19/this 到底是什么？/" itemprop="url">this 到底是什么？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-19T22:18:01+08:00">
                2018-01-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h4><ul>
<li>无论是否在严格模式下，在全局执行上下文中（在任何函数体外部）<code>this</code>都指代全局对象。</li>
<li>在浏览器中，全局对象是<code>window</code>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var message = 1</div><div class="line">console.log(this.message) // 1</div><div class="line">console.log(window.message) // 1</div></pre></td></tr></table></figure>
<hr>
<h4 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h4><ul>
<li><p>每个函数在被调用时都会自动取得两个特殊变量：<code>this</code> 和 <code>arguments</code>。除了箭头函数。</p>
</li>
<li><p><code>this</code>是函数的第一个参数（且必须是对象）,<code>arguments</code>是函数的第二个参数（包装成一个数组[]）。</p>
</li>
<li><p><code>this</code>是参数，所以只有在调用的时候才能确定。</p>
</li>
<li><p><code>this</code>为什么必须是对象，因为<code>this</code>就是函数与对象之间的羁绊。</p>
</li>
</ul>
<h5 id="普通模式：如果this是undefined或null，浏览器会把this变成window"><a href="#普通模式：如果this是undefined或null，浏览器会把this变成window" class="headerlink" title="普通模式：如果this是undefined或null，浏览器会把this变成window"></a>普通模式：如果<code>this</code>是<code>undefined</code>或<code>null</code>，浏览器会把<code>this</code>变成<code>window</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function f()&#123;</div><div class="line">	console.log(this)</div><div class="line">	console.log(arguments)</div><div class="line">&#125;</div><div class="line">f.call() // this 是 window</div><div class="line">f.call(null) // this 是 window</div><div class="line">f.call(undefined) // this 是 window</div></pre></td></tr></table></figure>
<h5 id="严格模式：默认第一个参数是undefined。如果传了第一个参数，那传什么this就是什么。"><a href="#严格模式：默认第一个参数是undefined。如果传了第一个参数，那传什么this就是什么。" class="headerlink" title="严格模式：默认第一个参数是undefined。如果传了第一个参数，那传什么this就是什么。"></a>严格模式：默认第一个参数是<code>undefined</code>。如果传了第一个参数，那传什么<code>this</code>就是什么。</h5><p>发明<code>JS</code>时，被要求要长得像<code>Java</code>，让<code>Java</code>程序员来学<code>JS</code>，但是他们发现<code>this</code>多余，就有了 <code>use strict</code> 严格模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function f()&#123;</div><div class="line">	// 严格模式</div><div class="line">  	&apos;use strict&apos;;</div><div class="line">	console.log(this)</div><div class="line">	console.log(arguments)</div><div class="line">&#125;</div><div class="line">f.call() // this 是 undefined</div><div class="line">f.call(null) // this 是 null</div><div class="line">f.call(undefined) // this 是 undefined</div><div class="line">f.call(&#123;name:&apos;frank&apos;&#125;) // &#123;name: &apos;frank&apos;&#125;, []</div><div class="line">f.call(&#123;name:&apos;frank&apos;&#125;,1,2) // &#123;name: &apos;frank&apos;&#125;, [1,2]</div></pre></td></tr></table></figure>
<h5 id="当以对象里的方法的方式调用函数时，它们的this是调用该函数的对象"><a href="#当以对象里的方法的方式调用函数时，它们的this是调用该函数的对象" class="headerlink" title="当以对象里的方法的方式调用函数时，它们的this是调用该函数的对象"></a>当以对象里的方法的方式调用函数时，它们的<code>this</code>是调用该函数的对象</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var message = &#123;</div><div class="line">	name: &apos;zhao&apos;,</div><div class="line">	Foo: function ()&#123;</div><div class="line">		console.log(message)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">	</div><div class="line">message.Foo() // &#123;name: &quot;zhao&quot;, Foo: ƒ&#125;</div><div class="line">//等同于</div><div class="line">this.Foo() // &#123;name: &quot;zhao&quot;, Foo: ƒ&#125;</div><div class="line">//等同于</div><div class="line">this.Foo.call(this) // &#123;name: &quot;zhao&quot;, Foo: ƒ&#125;</div></pre></td></tr></table></figure>
<h5 id="当一个函数用作构造函数时（使用new关键字），它的this被绑定到正在构造的新对象。"><a href="#当一个函数用作构造函数时（使用new关键字），它的this被绑定到正在构造的新对象。" class="headerlink" title="当一个函数用作构造函数时（使用new关键字），它的this被绑定到正在构造的新对象。"></a>当一个函数用作构造函数时（使用new关键字），它的<code>this</code>被绑定到正在构造的新对象。</h5><p>下面例子中，函数内的<code>this</code>被绑定到<code>human1</code>对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function Foo(name, city)&#123;</div><div class="line">	this.name = &apos;zhao&apos;;</div><div class="line">	this.city = &apos;beijing&apos;;</div><div class="line">&#125;</div><div class="line">	</div><div class="line">var human1 = new Foo() </div><div class="line"></div><div class="line">human1.name // &quot;zhao&quot;</div><div class="line">human1.city // &quot;beijing&quot;</div></pre></td></tr></table></figure>
<hr>
<p>参考：<a href="https://xiedaimala.com/" target="_blank" rel="external">写代码啦</a> </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/15/「构造函数模式」和「原型模式」/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhao Zhiying">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhao Zhiying">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/15/「构造函数模式」和「原型模式」/" itemprop="url">「构造函数模式」和「原型模式」</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-15T15:29:09+08:00">
                2018-01-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><ul>
<li>创建对象有两种方式：「对象字面量」和使用「new 表达式」。后者被称为「构造函数」。</li>
<li>如果只是一个单独的对象，直接使用「对象字面量」</li>
<li>如果创建一个有很多实例的对象，或者涉及继承，就用「构造函数模式」</li>
</ul>
<h5 id="构造函数的特点"><a href="#构造函数的特点" class="headerlink" title="构造函数的特点"></a>构造函数的特点</h5><ol>
<li>构造函数的首字母必须大写，用来区分于普通函数</li>
<li>内部使用的<code>this</code>对象，来指向即将要生成的实例对象</li>
<li>使用<code>new</code>操作符来创建实例对象</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function Foo(name, city)&#123;</div><div class="line">	this.name = name;</div><div class="line">	this.city = city;</div><div class="line">	this.walk = walk;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function walk()&#123;</div><div class="line">    console.log(&apos;走一步的代码&apos;)</div><div class="line">&#125;</div><div class="line">	</div><div class="line">var human1 = new Foo(&#123;name:&apos;zhao&apos;, city: &apos;beijing&apos;&#125;)</div><div class="line">var human2 = new Foo(&#123;name:&apos;zhao&apos;, city: &apos;beijing&apos;&#125;)</div></pre></td></tr></table></figure>
<h5 id="构造函数与普通函数的区别"><a href="#构造函数与普通函数的区别" class="headerlink" title="构造函数与普通函数的区别"></a>构造函数与普通函数的区别</h5><p>构造函数与普通函数的区别，在于调用它们的方式不同。</p>
<ul>
<li>任何函数，只要通过<code>new</code>操作符来调用，那它就可以作为构造函数。</li>
<li>而任何函数，如果不通过<code>new</code>操作符来调用，那它就是普通函数。</li>
</ul>
<h5 id="构造函数的缺点"><a href="#构造函数的缺点" class="headerlink" title="构造函数的缺点"></a>构造函数的缺点</h5><ol>
<li>在全局作用域中定义的函数实际上只能被某个对象调用，这让全局作用域有点名不副实。</li>
<li>更严重的是，当对象需要定义很多方法时，那就要定义多个全局函数。</li>
</ol>
<h5 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h5><p>通过使用原型链模式</p>
<hr>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><h5 id="什么是共有属性？"><a href="#什么是共有属性？" class="headerlink" title="什么是共有属性？"></a>什么是共有属性？</h5><p>当我们在写<code>var x1 = new x2</code>的时候：<code>x1</code>的类型是对象，<code>x2</code>的类型是函数对象。</p>
<pre><code>var n = new Number(1)
var s = new String(&quot;1&quot;)
var b = new Boolean(true)
var o = new Object()
</code></pre><p>上面代码中<code>n``s``b``o</code>这四个对象都有 <code>toString()</code> <code>valueOf()</code> 方法，如果每个对象中内存分别加上<code>toString()</code> <code>valueOf()</code>，这样就太占内存了。</p>
<p>解决办法：将<code>toString()</code> <code>valueOf()</code> 方法都放在一个对象里，<code>n1``n2``n3``n4</code>这四个对象的 <code>__proto__</code>引用它，而存放<code>toString()</code> <code>valueOf()</code>的对象就是共有属性，即 <code>Object.prototype</code>，如下图：</p>
<p><img src="https://i.loli.net/2018/01/26/5a6b32120b98d.png
"></p>
<h4 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a><code>prototype</code></h4><ul>
<li><p>每一个函数在创建后都会有一个属性<code>prototype</code>，这个属性指向「函数的原型对象」。这个对象的用途是包含可以「由特定类型的所有实例」共享的属性和方法(也叫共有属性)。</p>
</li>
<li><p>在默认情况下，所有「原型对象」都会自动获得一个<code>constructor(构造函数)</code>属性，这个属性是一个指向<code>prototype</code>属性「所在函数」的指针。 </p>
</li>
<li><p><strong>注意</strong>：由于这个<code>prototype</code>属性不标准，因此一般不提倡使用。<code>ES5</code>中用<code>Object.getPrototypeOf</code>函数获得一个对象的<code>prototype</code>。<code>ES6</code>中使用<code>Object.setPrototypeOf</code>可以直接修改一个对象的<code>prototype</code>。</p>
</li>
</ul>
<h4 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a><code>__proto__</code></h4><ul>
<li><p>在<code>ES5</code>之前没有标准的方法访问内置属性<code>prototype</code>，于是很多浏览器都给「每一个对象」提供了一个属性<code>__proto__</code>，通过<code>__proto__</code>就可以访问<code>prototype</code>。</p>
</li>
<li><p>这个连接存在于「实例」与「构造函数的原型对象」之间，而不是存在「实例」与「构造函数」之间</p>
</li>
</ul>
<h5 id="什么叫原型链？"><a href="#什么叫原型链？" class="headerlink" title="什么叫原型链？"></a>什么叫原型链？</h5><pre><code>function Foo(){}
var obj = new Foo()
</code></pre><p>当我们输入<code>obj.toString</code>时，JS 引擎会做下面的事情：</p>
<ol>
<li>看看 <code>obj</code> 对象本身有没有 <code>toString</code> 属性。没有就走到下一步。</li>
<li>看看 <code>obj.__proto__</code> 对象有没有 <code>toString</code> 属性。</li>
<li>如果 <code>obj.__proto__</code> 没有，那么浏览器会继续查看 <code>obj.__proto__.__proto__</code> ，直到找到 <code>toString</code> 或者 <code>__proto__</code> 为<code>null</code>。</li>
</ol>
<p>上面由<code>__proto__</code>组成直到 <code>__proto__</code> 为<code>null</code>的链子，就叫做「原型链」。「原型链」实际上就是<code>JS</code>中数据继承的「继承链」。</p>
<p><img src="https://i.loli.net/2018/01/26/5a6b1c4a8d1d0.png
"></p>
<h5 id="默认原型"><a href="#默认原型" class="headerlink" title="默认原型"></a>默认原型</h5><ul>
<li><p>所有引用类型都默认继承了<code>Object</code>，这个继承是通过原型链实现的。</p>
</li>
<li><p>所有函数的默认原型都是<code>Object</code>的实例，因此默认原型都会有一个指针，指向<code>Object.prototype</code>。这也是所有自定义类型都会继承<code>toString()</code> <code>valueOf()</code>等默认方法的根本原因。</p>
</li>
<li><p>而每个对象都有<code>__proto__</code>属性，<code>Object.prototype</code>也是对象，在<code>Object.prototype</code>中</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Object.prototype.__proto__ = null</div></pre></td></tr></table></figure>
<h5 id="原型模式的缺点"><a href="#原型模式的缺点" class="headerlink" title="原型模式的缺点"></a>原型模式的缺点</h5><ol>
<li>原型模式无法为构造函数传递初始化参数，结果所有实例在默认情况下都取得相同的属性值。</li>
<li>由于实例对象的<code>__proto__</code>都指向了<code>Foo.prototype</code>，使得他们的属性值无法保持独立。</li>
</ol>
<p>如下代码中，数组<code>interest</code>存在于<code>Foo.prototype</code>中而不是<code>human1</code>中，当<code>human1.interest.push(&#39;swimming&#39;)</code>更改这个数组时，<code>human2.interest</code>也被更改了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function Foo()&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Foo.prototype = &#123;</div><div class="line">	constructor: Foo, </div><div class="line">	name: &apos;zhao&apos;,</div><div class="line">	city: &apos;beijing&apos;,</div><div class="line">	interest: [&apos;reading&apos;, &apos;fitness&apos;],</div><div class="line">	walk: function()&#123;</div><div class="line">	 	console.log(&apos;走一步的代码&apos;);</div><div class="line">	 &#125;</div><div class="line">&#125;</div><div class="line">	</div><div class="line">var human1 = new Foo()</div><div class="line">var human2 = new Foo()</div><div class="line"></div><div class="line">human1.interest.push(&apos;swimming&apos;)</div><div class="line"></div><div class="line">console.log(human1.interest)//[&apos;reading&apos;, &apos;fitness&apos;, &apos;swimming&apos;]</div><div class="line">console.log(human2.interest)//[&apos;reading&apos;, &apos;fitness&apos;, &apos;swimming&apos;]</div></pre></td></tr></table></figure>
<h5 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h5><p>组合使用「构造函数模式」和「原型模式」。</p>
<hr>
<h3 id="组合使用「构造函数模式」和「原型模式」"><a href="#组合使用「构造函数模式」和「原型模式」" class="headerlink" title="组合使用「构造函数模式」和「原型模式」"></a>组合使用「构造函数模式」和「原型模式」</h3><p>「构造函数」用于定义实例属性，而「原型模式」用于定义和共享的属性和方法。这样，每个实例都会有自己的一份实例属性副本，同时又共享着属性和方法，最大限度地节省了内存。</p>
<h5 id="constructor-属性"><a href="#constructor-属性" class="headerlink" title="constructor 属性"></a><code>constructor</code> 属性</h5><ul>
<li><p><code>new</code>操作为了记录临时对象是由哪个函数创建的，在默认情况下，所有原型对象都会自动获得一个<code>constructor(构造函数)</code>属性，这个属性是一个指向<code>prototype</code>属性「所在函数」的指针。</p>
</li>
<li><p>如果你重新对原型对象赋值，那么这个<code>constructor</code>属性就没了，所以同时需要给 <code>constructor</code>重新赋值</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function Foo(name, city)&#123;</div><div class="line">	this.name = name;</div><div class="line">	this.city = city;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Foo.prototype = &#123;</div><div class="line">	constructor: Foo,</div><div class="line">	walk: function()&#123;</div><div class="line">		console.log(&apos;走一步的代码&apos;)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">	</div><div class="line">var human1 = new Foo(&#123;name:&apos;zhao&apos;, city: &apos;beijing&apos;&#125;)</div><div class="line">var human2 = new Foo(&#123;name:&apos;zhao&apos;, city: &apos;beijing&apos;&#125;)</div></pre></td></tr></table></figure>
<p>对上面代码的理解如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// human1 和 human2 是构造函数 Foo() 声明的两个实例，这两个对象有属性__proto__ ，指向构造函数的原型对象。</div><div class="line">human1.__proto__ = Foo.prototype</div><div class="line">human2.__proto__ = Foo.prototype</div><div class="line"></div><div class="line">//构造函数 Foo() 是方法，也是对象，它的 __proto__ 属性也指向它的构造函数的原型对象。函数的构造函数是 Function。</div><div class="line">Foo.__proto__ = Function.prototype</div><div class="line"></div><div class="line">// 原型对象也是对象，它的 __proto__ 属性也指向它的构造函数的原型对象。</div><div class="line">Foo.prototype.__proto__ = Object.prototype</div><div class="line"></div><div class="line">// 原型对象的 constructor(构造函数) 属性，指向 prototype 属性所在函数。故得到如下：</div><div class="line">Foo.prototype.constructor === Foo</div><div class="line">human1.__proto__.constructor === Foo</div><div class="line">human2.__proto__.constructor === Foo</div></pre></td></tr></table></figure>
<hr>
<p>参考：<a href="https://xiedaimala.com/" target="_blank" rel="external">写代码啦</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/09/JS 内存/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhao Zhiying">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhao Zhiying">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/09/JS 内存/" itemprop="url">JS 内存</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-09T16:10:48+08:00">
                2018-01-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="stack栈内存-和-heap堆内存"><a href="#stack栈内存-和-heap堆内存" class="headerlink" title="stack栈内存 和 heap堆内存"></a><code>stack</code>栈内存 和 <code>heap</code>堆内存</h3><ul>
<li>比如买一个 8G 的内存条</li>
<li>开机时内存分配：操作系统 512M，浏览器打开就占用 1G(100M 给<code>HTML</code>+<code>CSS</code>+<code>JS</code>+网络<code>HTTP</code>+其他)  </li>
<li><code>JS</code>最多分到 100M 内存</li>
<li><code>JS</code>引擎将内存分为代码区和数据区</li>
<li>数据区分为<code>Stack</code>（栈内存）和<code>Heap</code>（堆内存）</li>
<li>基本类型的数据直接存在<code>Stack</code>里（数字64位，字符16位）</li>
<li>复杂类型的数据是把<code>Heap</code>地址存在<code>Stack</code>里</li>
</ul>
<hr>
<h3 id="遇到问题就画图，不要分析。"><a href="#遇到问题就画图，不要分析。" class="headerlink" title="遇到问题就画图，不要分析。"></a>遇到问题就画图，不要分析。</h3><h5 id="举例1"><a href="#举例1" class="headerlink" title="举例1"></a>举例1</h5><pre><code>var a = {name: &quot;tang&quot;}
var b = a
b = {name: &quot;zhao&quot;}
a.name = ? // &quot;tang&quot;
</code></pre><p>当执行 <code>var b = a</code> 时，内存变化如下：</p>
<p><img src="https://i.loli.net/2018/01/24/5a6892882ff3c.png
">    </p>
<p>当执行 <code>b = { name: &quot;zhao&quot; }</code> 时，内存变化如下：</p>
<p><img src="https://i.loli.net/2018/01/24/5a688d4447585.png
"></p>
<h5 id="举例2"><a href="#举例2" class="headerlink" title="举例2"></a>举例2</h5><pre><code>var a = {name: &quot;tang&quot;}
var b = a
b.name = &apos;zhao&apos;
a.name = ? // &quot;zhao&quot;
</code></pre><p>当执行 <code>b.name = &quot;zhao&quot;</code>时，内存变化如下：</p>
<p><img src="https://i.loli.net/2018/01/24/5a688d63302b0.png
">    </p>
<h5 id="举例3"><a href="#举例3" class="headerlink" title="举例3"></a>举例3</h5><pre><code>var a = {name: &quot;tang&quot;}
var b = a
b = null
a = ? // {name: &quot;tang&quot;}
</code></pre><p>当执行 <code>b = null</code>时，内存变化如下：</p>
<p><img src="https://i.loli.net/2018/01/24/5a688d7803b75.png
">    </p>
<hr>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>如果一个对象没有被引用，它就是垃圾，将被回收。</p>
<h5 id="举例1-1"><a href="#举例1-1" class="headerlink" title="举例1"></a>举例1</h5><pre><code>var a = {name: &quot;tang&quot;}
var b = {name: &quot;zhao&quot;}
a = b 
// 这时 {name: &quot;tang&quot;} 就是垃圾
</code></pre><h5 id="举例2-1"><a href="#举例2-1" class="headerlink" title="举例2"></a>举例2</h5><p>请问下面的<code>function(){}</code>会被回收吗？</p>
<pre><code>var fn = function(){}
document.body.onclick = fn
fn = null
</code></pre><p>当执行到 <code>document.body.onclick = fn</code>时，内存变化如下：</p>
<p><img src="https://i.loli.net/2018/01/24/5a6894373204b.png
">    </p>
<p>当执行到 <code>fn = null</code>时，由于<code>function(){}</code>仍然被<code>document</code>引用，故不会被回收，内存变化如下:</p>
<p><img src="https://i.loli.net/2018/01/24/5a6894597cc45.png
"></p>
<h5 id="举例3-1"><a href="#举例3-1" class="headerlink" title="举例3"></a>举例3</h5><p>下面的<code>function(){}</code>会被回收</p>
<pre><code>var fn = function(){}
document.body.onclick = fn
document.body.onclick = null
</code></pre><ul>
<li>注意：IE 的 bug，使得该被标记为垃圾的没有被标记，这叫做‘内存泄漏’。</li>
<li>解决办法：页面关闭前，将所有事件 = null</li>
</ul>
<hr>
<h3 id="基本类型（值）和复杂类型（引用）的区别"><a href="#基本类型（值）和复杂类型（引用）的区别" class="headerlink" title="基本类型（值）和复杂类型（引用）的区别"></a>基本类型（值）和复杂类型（引用）的区别</h3><p>基本类型：<code>Number</code> <code>String</code> <code>undefined</code> <code>null</code> <code>Boolean</code> <code>Symbol</code><br>复杂类型：<code>Object</code> <code>Function</code> <code>Array</code>  <code>Date</code> <code>RegExp</code></p>
<h5 id="区别：基本类型的变量存的是值，复杂类型的变量存的是内存地址。"><a href="#区别：基本类型的变量存的是值，复杂类型的变量存的是内存地址。" class="headerlink" title="区别：基本类型的变量存的是值，复杂类型的变量存的是内存地址。"></a>区别：基本类型的变量存的是值，复杂类型的变量存的是内存地址。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var n1 = new object()</div><div class="line">var n2 = 1</div></pre></td></tr></table></figure>
<p>n1 和 n2 在内存的情况如下：</p>
<p><img src="https://i.loli.net/2018/01/27/5a6c49bee3322.png
"></p>
<p>值得注意的是：</p>
<ul>
<li>由于历史原因要求<code>JS</code>长得像<code>Java</code>，故发明了<code>var n = new Number(1)</code>这种写法。</li>
<li>但是<code>var n = 1</code>这种写法更简单，这种写法有个缺点：因为基本类型没有属性，不能使用<code>toString</code>方法。</li>
<li>于是 JS之父 发明了一个妙计，当写<code>n.toString()</code>时，声明一个临时对象<code>temp = new Number(n)</code>，将<code>temp.toString()</code>的值作为<code>n.toString()</code>的值，转换完成后就干掉<code>temp</code>，内存变化如下：</li>
</ul>
<p><img src="https://i.loli.net/2018/01/25/5a69a04b8bfd6.png
"></p>
<p>引用《JavaScript 高级程序设计》里的话来总结：</p>
<ul>
<li>为了便于操作基本类型值，<code>ECMAScript</code> 还提供了3个特殊的引用类型（也叫基本包装类型），分别是 <code>Boolean</code> <code>Number</code> <code>String</code> 。这些类型与其他引用类型相似，同时具有各自的基本类型相应的特殊行为。</li>
<li>引用类型与基本包装类型的主要区别就是对象的生存期。使用<code>new</code>操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。</li>
</ul>
<hr>
<h3 id="深拷贝-VS-浅拷贝"><a href="#深拷贝-VS-浅拷贝" class="headerlink" title="深拷贝 VS 浅拷贝"></a>深拷贝 VS 浅拷贝</h3><p>对于基本类型来说，只有深拷贝。这里我们只讲对象。</p>
<h5 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h5><p>对于对象来说，深拷贝是指在<code>栈内存</code>中新增一个指针，并且在<code>堆内存</code>中申请了一个新的内存。</p>
<pre><code>var a = {name:&quot;tang&quot;}
var b = a 
b.name = &quot;zhao&quot;;  
//a.name = &quot;tang&quot;
</code></pre><p><img src="https://i.loli.net/2018/01/24/5a68936065884.png
">    </p>
<h5 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h5><p>对于对象来说，浅拷贝只是在<code>栈内存</code>中新增一个指针指向原有的内存，只是拷贝了内存地址（<code>Heap</code>地址）。</p>
<pre><code>var a = {name:&quot;tang&quot;}
var b = a
b.name = &quot;zhao&quot;
//a.name = &quot;zhao&quot;
</code></pre><p><img src="https://i.loli.net/2018/01/24/5a6892b18918c.png
">    </p>
<h5 id="如何实现深拷贝？（后续来补）"><a href="#如何实现深拷贝？（后续来补）" class="headerlink" title="如何实现深拷贝？（后续来补）"></a>如何实现深拷贝？（后续来补）</h5><hr>
<p>参考：<a href="https://xiedaimala.com/" target="_blank" rel="external">写代码啦</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/07/JS 的三大对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhao Zhiying">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhao Zhiying">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/07/JS 的三大对象/" itemprop="url">JS 的三大对象</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-07T21:24:37+08:00">
                2018-01-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="本地对象（native-object）"><a href="#本地对象（native-object）" class="headerlink" title="本地对象（native object）"></a>本地对象（<code>native object</code>）</h4><ul>
<li><p><code>ECMA-262</code>把本地对象定义为“独立于宿主环境的<code>ECMAScript</code>实现提供的对象”。</p>
</li>
<li><p>简单来说，本地对象就是<code>ECMA-262</code>定义的类（引用类型）。</p>
</li>
<li><p>这些引用类型在运行过程中需要通过<code>new</code>来创建所需的实例对象。</p>
</li>
<li><p>包含：<code>Object</code> <code>Function</code> <code>Array</code>  <code>Date</code> <code>RegExp</code></p>
<p>  和三个基本包装类型 <code>String</code> <code>Boolean</code> <code>Number</code></p>
</li>
</ul>
<hr>
<h4 id="内置对象（built-in-object）"><a href="#内置对象（built-in-object）" class="headerlink" title="内置对象（built-in object）"></a>内置对象（<code>built-in object</code>）</h4><ul>
<li><p><code>ECMA-262</code>把内置对象定义为“由<code>ECMAScript</code>实现提供的、独立于宿主环境的所有对象，在<code>ECMAScript</code>程序开始执行时出现”。这意味着开发者不必明确实例化内置对象，它已被实例化了。</p>
</li>
<li><p><code>ECMA-262</code>只定义了两个内置对象，即<code>Global</code>和<code>Math</code>。</p>
</li>
<li><p><strong>根据定义，内置对象是本地对象的一种。</strong></p>
</li>
</ul>
<hr>
<h4 id="宿主对象（host-object）"><a href="#宿主对象（host-object）" class="headerlink" title="宿主对象（host object）"></a>宿主对象（<code>host object</code>）</h4><ul>
<li><p><code>ECMAScript</code>中的“宿主”是指网页的运行环境，即“操作系统”和“浏览器”。</p>
</li>
<li><p><code>ECMAScript</code>官方未定义的对象都属于宿主对象。包含两大类，一个是宿主提供，一个是自定义类对象</p>
</li>
<li><p>所有非本地对象都是宿主对象，即由<code>ECMAScript</code>实现的宿主环境提供的对象。</p>
</li>
<li><p>所有的<code>BOM</code>和<code>DOM</code>都是宿主对象。因为其对于不同的“宿主”环境所展示的内容不同。</p>
</li>
</ul>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/04/DOM 事件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhao Zhiying">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhao Zhiying">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/04/DOM 事件/" itemprop="url">DOM 事件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-04T15:31:21+08:00">
                2018-01-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p><code>javascript</code>操作<code>CSS</code>称为<code>脚本化CSS</code>，而<code>javascript</code>与<code>HTML</code>的交互是通过事件实现的。事件就是文档或浏览器窗口中发生的一些特定的交互瞬间，而事件流(又叫事件传播)描述的是从页面中接收事件的顺序。</p>
<hr>
<h3 id="DOM-事件发展"><a href="#DOM-事件发展" class="headerlink" title="DOM 事件发展"></a>DOM 事件发展</h3><h4 id="DOM-Level-0-事件"><a href="#DOM-Level-0-事件" class="headerlink" title="DOM Level 0 事件"></a><code>DOM Level 0 事件</code></h4><p>主要分为2个：</p>
<p>1.标签内写 onclick 事件</p>
<pre><code>&lt;button id=&quot;button1&quot; onclick=&quot;console.log(&apos;hi&apos;)&quot;&gt;A&lt;/button&gt;
</code></pre><p>2.JS 里写 onlicke=function (){} 函数</p>
<pre><code>document.getElementById(&quot;button1&quot;).onclick = function print(){
    console.log(&apos;hi&apos;)
}
</code></pre><h4 id="DOM-Level-1-事件"><a href="#DOM-Level-1-事件" class="headerlink" title="DOM Level 1 事件"></a><code>DOM Level 1 事件</code></h4><p><code>DOM Level 1</code>于1998年10月1日成为 W3C 推荐标准。但是标准中并没有定义事件相关的内容，所以没有所谓的 <code>DOM Level 1</code> 事件模型。</p>
<h4 id="DOM-Level-2-事件"><a href="#DOM-Level-2-事件" class="headerlink" title="DOM Level 2 事件"></a><code>DOM Level 2 事件</code></h4><ul>
<li><p>在<code>DOM Level 0 事件</code>的基础上弥补了一个处理程序无法同时绑定多个处理函数的缺点，允许给一个处理程序添加多个处理函数。</p>
</li>
<li><p>只定义了两个方法，分别用来绑定和解绑事件：</p>
<p>  <code>addEventListener()</code>   对应 IE8 中的 <code>attachEvent()</code><br>  <code>removeEventListener()</code>对应 IE8 中的 <code>detachEvent()</code></p>
</li>
<li><p>都有三个参数：</p>
<p>  参数1：事件名（不要使用 “on” 前缀）<br><br>  参数2：事件触发时执行的函数<br><br>  参数3：事件是否在捕获或冒泡阶段执行（第三个参数为 true，为捕获阶段；不传第三个参数或者传 false 为冒泡阶段）<br></p>
<p>  <strong>注意</strong>：如果又有捕获又有冒泡，那就不区分捕获还是冒泡，按照代码顺序。</p>
</li>
</ul>
<p>HTML</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;grand1&quot;&gt;</div><div class="line">   爷爷</div><div class="line">    &lt;div id=&quot;parent1&quot;&gt;</div><div class="line">     爸爸</div><div class="line">      &lt;div id=&quot;child1&quot;&gt;</div><div class="line">       儿子</div><div class="line">      &lt;/div&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line"> &lt;/div&gt;</div></pre></td></tr></table></figure>
<p>JS</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">grand1.addEventListener(&apos;click&apos;, function fn1()&#123;</div><div class="line">  console.log(&apos;爷爷&apos;)</div><div class="line">&#125;,true)//捕获阶段</div><div class="line">parent1.addEventListener(&apos;click&apos;, function fn2()&#123;</div><div class="line">  console.log(&apos;爸爸&apos;)</div><div class="line">&#125;,false)//冒泡阶段</div><div class="line">child1.addEventListener(&apos;click&apos;, function fn3()&#123;</div><div class="line">  console.log(&apos;儿子&apos;)</div><div class="line">&#125;)//冒泡阶段</div><div class="line">//当点击‘儿子’时，打印的顺序是：爷爷、儿子、爸爸</div></pre></td></tr></table></figure>
<h4 id="DOM-Level-3-事件"><a href="#DOM-Level-3-事件" class="headerlink" title="DOM Level 3 事件"></a><code>DOM Level 3 事件</code></h4><p><code>DOM Level 3 事件</code>在<code>DOM Level 2 事件</code>的基础上添加了更多的事件类型，全部类型如下：</p>
<pre><code>UI事件，当用户与页面上的元素交互时触发，如：load、scroll
焦点事件，当元素获得或失去焦点时触发，如：blur、focus
鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup
滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel
文本事件，当在文档中输入文本时触发，如：textInput
键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress
合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart
变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified

同时DOM3级事件也允许使用者自定义一些事件。
</code></pre><hr>
<h3 id="DOM-事件流"><a href="#DOM-事件流" class="headerlink" title="DOM 事件流"></a><code>DOM 事件流</code></h3><p>事件流又称为事件传播，<code>DOM Level 2 事件</code>规定的事件流包括三个阶段：</p>
<pre><code>（1）捕获阶段：事件从 Document 节点自上而下向目标节点传播的阶段；
（2）目标阶段：真正的目标节点正在处理事件的阶段；
（3）冒泡阶段：事件从目标节点自上而下向 Document节点传播的阶段。
</code></pre><h4 id="stopPropagation"><a href="#stopPropagation" class="headerlink" title="stopPropagation()"></a><code>stopPropagation()</code></h4><p>在整个事件流的任何位置通过调用事件的<code>stopPropagation()</code>方法可以停止事件的传播过程    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">grand1.addEventListener(&apos;click&apos;, function fn1(e)&#123;</div><div class="line">  console.log(&apos;爷爷&apos;)</div><div class="line">  e.stopPropagation()//事件不再被分派到其他节点</div><div class="line">&#125;,true)</div><div class="line">parent1.addEventListener(&apos;click&apos;, function fn2()&#123;</div><div class="line">  console.log(&apos;爸爸&apos;)</div><div class="line">&#125;,false)</div><div class="line">child1.addEventListener(&apos;click&apos;, function fn3()&#123;</div><div class="line">  console.log(&apos;儿子&apos;)</div><div class="line">&#125;)</div><div class="line">//当点击‘儿子’时，打印：爷爷</div></pre></td></tr></table></figure>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/01/实现一个 jQuery 的 API/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhao Zhiying">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhao Zhiying">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/01/实现一个 jQuery 的 API/" itemprop="url">实现一个 jQuery 的 API</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-01T16:44:38+08:00">
                2018-01-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="getSiblings获取一个节点的所有兄弟节点"><a href="#getSiblings获取一个节点的所有兄弟节点" class="headerlink" title="getSiblings获取一个节点的所有兄弟节点"></a><code>getSiblings</code>获取一个节点的所有兄弟节点</h4><pre><code>&lt;ul&gt;
  &lt;li id=&quot;item1&quot;&gt;选项1&lt;/li&gt;
  &lt;li id=&quot;item2&quot;&gt;选项2&lt;/li&gt;
  &lt;li id=&quot;item3&quot;&gt;选项3&lt;/li&gt;
  &lt;li id=&quot;item4&quot;&gt;选项4&lt;/li&gt;
  &lt;li id=&quot;item5&quot;&gt;选项5&lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>定义一个伪数组 <code>array</code>，然后遍历伪数组，将<code>!== item3</code>的节点放进这个伪数组，最后得到这个节点的所有兄弟节点。</p>
<pre><code>var allChildren = item3.parentNode.children 
var array = { 
    length:0
}
for(let i = 0; i&lt;allChildren.length; i++){
    if (allChildren[i] !== item3){
        array[array.length] = allChildren[i]
        array.length += 1
    }
}
</code></pre><p>封装成函数</p>
<pre><code>function getSiblings(node){
    var allChildren = node.parentNode.children 
    var array = { 
        length:0
    }
    for(let i = 0; i&lt;allChildren.length; i++){
        if (allChildren[i] !== node){
            array[array.length] = allChildren[i]
            array.length += 1
        }
    }
    return array
}
getSiblings(item3)//调用
</code></pre><h4 id="addClass为元素添加指定的样式类名"><a href="#addClass为元素添加指定的样式类名" class="headerlink" title="addClass为元素添加指定的样式类名"></a><code>addClass</code>为元素添加指定的样式类名</h4><pre><code>item3.classList.add(&apos;a&apos;)
item3.classList.add(&apos;b&apos;)
item3.classList.add(&apos;c&apos;)
</code></pre><p>上面代码优化后如下（这里用到了箭头函数）</p>
<pre><code>var classes = {&apos;a&apos;:true, &apos;b&apos;:true, &apos;c&apos;:false,}
classes.forEach((value) =&gt; item3.classList.add(value))
</code></pre><p>加上<code>remove</code></p>
<pre><code>var classes = {&apos;a&apos;:true, &apos;b&apos;:true, &apos;c&apos;:false,}
for(let key in classes){
    var value = classes[key]
    if(value){
        item3.classList.add(key)
    }else{
        item3.classList.remove(key)
    }
}
</code></pre><p>封装成函数</p>
<pre><code>function addClass(node,classes){
    for(let key in classes){
        var value = classes[key]
        if(value){
            node.classList.add(key)
        }else{
            node.classList.remove(key)
        }
    }    
}    
addClass(item3,{&apos;a&apos;:true, &apos;b&apos;:true, &apos;c&apos;:false,})//调用
</code></pre><p>优化代码（这里用到了三元运算符）</p>
<pre><code>function addClass(node,classes){
  for(let key in classes){
      var value = classes[key]
      var methodName = value ? &apos;add&apos; : &apos;remove&apos;
      node.classList[methodName](key)
    }    
}    
addClass(item3,{&apos;a&apos;:true,&apos;b&apos;:true,&apos;c&apos;:false,})//调用
</code></pre><p>上面代码等于下面</p>
<pre><code>function addClass(node,classes){
    classes.forEach((value) =&gt; node.classList.add(value))
}    
addClass(item3,[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;])//调用
</code></pre><p>上面两个 API 的弊端：如果有人已经定义过getSiblings ，会被这次覆盖。而且不方便调用。运用 <strong>命名空间</strong> 能解决这个问题。</p>
<pre><code>window.zzdom = {} //声明变量名 zzdom
zzdom.getSiblings = getSiblings 
zzdom.addClass = addClass
//调用
zzdom.getSiblings.call(item3)  
zzdom.addClass.call(items, {a:true, b:false, c:true})    
</code></pre><p>代码更新如下</p>
<pre><code>window.zzdom = {}        
zzdom.getSiblings = function (node){ 
var allChildren = node.parentNode.children 
var array = { 
    length:0
}
for(let i = 0; i&lt;allChildren.length; i++){
    if (allChildren[i] !== node){
        array[array.length] = allChildren[i]
        array.length += 1
    }
}
return array
}
zzdom.addClass = function (node,classes){
  classes.forEach((value) =&gt; node.classList.add(value))
}
//调用
zzdom.getSiblings(item3)
zzdom.addClass(item3,[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;])
</code></pre><p>但是相比下，下面这种调用方法更好</p>
<pre><code>//调用
item3.getSiblings(item3)
item3.addClass(item3,[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;])
</code></pre><p>解决办法：更改<code>Node</code>原型</p>
<pre><code>Node.prototype.getSiblings = function (){ 
    var allChildren = this.parentNode.children 
    var array = { 
        length:0
    }
    for(let i = 0; i&lt;allChildren.length; i++){
        if (allChildren[i] !== this){
            array[array.length] = allChildren[i]
            array.length += 1
        }
    }
    return array
    }
    Node.prototype.addClass = function (classes){
        classes.forEach((value) =&gt; this.classList.add(value))
}
//调用
item3.getSiblings.call(item3)
item3.addClass.call(item3,[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;])
</code></pre><blockquote>
<p>注意：<code>this</code>是调用函数时的第一个参数。</p>
</blockquote>
<p>上面代码弊端：如果之前声明过<code>getSiblings</code>和<code>addClass</code>，会被这次声明覆盖。<br>那么不更改原型，解决办法如下：</p>
<pre><code>window.jQuery = function (node){
    return{
      getSiblings: function (){ 
          var allChildren = node.parentNode.children 
          var array = { length: 0 }
          for(let i = 0; i&lt;allChildren.length; i++){
            if (allChildren[i] !== node){
                array[array.length] = allChildren[i]
                array.length += 1
            }
          }
          return array
      },
      addClass: function (classes){
        classes.forEach((value) =&gt; node.classList.add(value))
      }
   }
}
//调用
var node2 = jQuery(item3)
node2.getSiblings()
node2.addClass([&apos;a&apos;,&apos;b&apos;,&apos;c&apos;])
</code></pre><p>增加类型检测：字符串<code>string</code>或选择器<code>selector</code></p>
<pre><code>window.jQuery = function (nodeOrSelector){
    let node
    if(typeof nodeOrSelector === &apos;string&apos;){
        node = document.querySelector(nodeOrSelector)
    }else{
        node = nodeOrSelector
    }

    return{
      getSiblings: function (){ 
          var allChildren = node.parentNode.children 
          var array = { length: 0 }
          for(let i = 0; i&lt;allChildren.length; i++){
            if (allChildren[i] !== node){
                array[array.length] = allChildren[i]
                array.length += 1
            }
          }
          return array
      },
      addClass: function (classes){
        classes.forEach((value) =&gt; node.classList.add(value))
      }
   }
}
//调用
var node2 = jQuery(&apos;#item3&apos;)
node2.getSiblings()
node2.addClass([&apos;a&apos;,&apos;b&apos;,&apos;c&apos;])
</code></pre><h4 id="addClass操作多个节点"><a href="#addClass操作多个节点" class="headerlink" title="addClass操作多个节点"></a><code>addClass</code>操作多个节点</h4><pre><code>window.jQuery = function (nodeOrSelector){
    let nodes = {}
    if(typeof nodeOrSelector === &apos;string&apos;){
       //伪数组
       nodes = document.querySelectorAll(nodeOrSelector)
    }else if(nodeOrSelector instanceof Node){
        //伪数组，保持返回结果一致
        nodes = {
            0: nodeOrSelector,
            length: 1
        }
    }
    return nodes
}    
//调用
var node2 = jQuery(&apos;ul &gt; li&apos;)
console.log(node2)//__proto__:NodeList
</code></pre><p>加一个临时变量，去掉多余的原型链。</p>
<pre><code>window.jQuery = function (nodeOrSelector){
    let nodes = {}
    if(typeof nodeOrSelector === &apos;string&apos;){
        let temp=document.querySelectorAll(nodeOrSelector)
        for(let i = 0; i&lt;temp.length; i++){
            nodes[i] = temp[i]
        }
        nodes.length = temp.length
    }else if(nodeOrSelector instanceof Node){
        nodes = {
            0: nodeOrSelector,
            length: 1
        }
    }            
    return nodes
}    
//调用
var node2 = jQuery(&apos;ul &gt; li&apos;)
console.log(node2)//__proto__:Object 
</code></pre><p>添加<code>addClass</code>后代码如下</p>
<pre><code>window.jQuery = function (nodeOrSelector){
    let nodes = {}
    if(typeof nodeOrSelector === &apos;string&apos;){
        let temp=document.querySelectorAll(nodeOrSelector)
        for(let i = 0; i&lt;temp.length; i++){
            nodes[i] = temp[i]
        }
        nodes.length = temp.length
    }else if(nodeOrSelector instanceof Node){
        nodes = {
            0: nodeOrSelector,
            length: 1
        }
    }    
    nodes.addClass = function(classes){
        classes.forEach((value)=&gt;{
            for(let i=0; i&lt;nodes.length; i++){
                nodes[i].classList.add(value)
            }
        })
    }    
    return nodes
}    
//调用
var node2 = jQuery(&apos;ul &gt; li&apos;)
node2.addClass([&apos;red&apos;])//将所有`div`的`class`添加一个`red`
</code></pre><h4 id="添加setText"><a href="#添加setText" class="headerlink" title="添加setText"></a>添加<code>setText</code></h4><pre><code>window.jQuery = function (nodeOrSelector){
    let nodes = {}
    if(typeof nodeOrSelector === &apos;string&apos;){
        let temp=document.querySelectorAll(nodeOrSelector)
        for(let i = 0; i&lt;temp.length; i++){
            nodes[i] = temp[i]
        }
        nodes.length = temp.length
    }else if(nodeOrSelector instanceof Node){
        nodes = {
            0: nodeOrSelector,
            length: 1
        }
    }    
    nodes.addClass = function(classes){
        classes.forEach((value)=&gt;{
            for(let i=0; i&lt;nodes.length; i++){
                nodes[i].classList.add(value)
            }
        })
    }    
    //`getText`获取文本
    nodes.getText = function(){
        var texts = []
        for(let i=0; i&lt;nodes.length; i++){
            texts.push(nodes[i].textContent)
        }
        return texts
    }    
    //`setText`设置文本
    nodes.setText = function(text){
        for(let i=0;i&lt;nodes.length; i++){
            nodes[i].textContent = text
        }
    }    
    return nodes
}    
var node2 = jQuery(&apos;ul &gt; li&apos;)
node2.addClass([&apos;red&apos;])//将所有`div`的`class`添加一个`red`
node2.setText(&apos;hi&apos;)//将所有`div`的`textContent`改为`hi`
</code></pre><p>但是，对于<code>jQuery</code>来说，非常讨厌写<code>set</code>和<code>get</code>。更改如下：</p>
<pre><code>    window.jQuery = function (nodeOrSelector){
    let nodes = {}
    if(typeof nodeOrSelector === &apos;string&apos;){
        let temp=document.querySelectorAll(nodeOrSelector)
        for(let i = 0; i&lt;temp.length; i++){
            nodes[i] = temp[i]
        }
        nodes.length = temp.length
    }else if(nodeOrSelector instanceof Node){
        nodes = {
            0: nodeOrSelector,
            length: 1
        }
    }    
    nodes.addClass = function(classes){
        classes.forEach((value)=&gt;{
            for(let i=0; i&lt;nodes.length; i++){
                nodes[i].classList.add(value)
            }
        })
    }    
    nodes.text = function (text){
        if(text === undefined){
            var texts = []
            for(let i=0; i&lt;nodes.length; i++){
             texts.push(nodes[i].textContent)
          }
           return texts
       }else{
            for(let i=0;i&lt;nodes.length; i++){
            nodes[i].textContent = text
        }
      }    
    }
    return nodes
}    
var node2 = jQuery(&apos;ul &gt; li&apos;)
node2.addClass([&apos;red&apos;])//将所有`div`的`class`添加一个`red`
node2.text(&apos;hi&apos;)//将所有`div`的`textContent`改为`hi`
</code></pre><hr>
<p>参考：[写代码啦] (<a href="https://xiedaimala.com/" target="_blank" rel="external">https://xiedaimala.com/</a>)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/30/DOM API/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhao Zhiying">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhao Zhiying">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/30/DOM API/" itemprop="url">DOM 常用 API</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-30T20:47:31+08:00">
                2017-12-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="DOM-理解"><a href="#DOM-理解" class="headerlink" title="DOM 理解"></a>DOM 理解</h5><pre><code>DOM（Document Object Model）是一棵树，树上有 Node ，Node 是一个构造函数（object 的一种）。
Node 分为 Document（html）、Element（标签）和 Text（文本），以及其他不重要的 Attribute（属性）、Comment（注释）。

* Document：XML(HTML 是 XML 的衍生品)
* Element：节点对象代表文档树中的一个节点。
* Text：模型
</code></pre><hr>
<h5 id="DOM-主要功能"><a href="#DOM-主要功能" class="headerlink" title="DOM 主要功能"></a>DOM 主要功能</h5><pre><code>页面中的节点通过构造函数构造出对应的对象，这也叫 DOM API。￼
</code></pre><hr>
<h5 id="节点的类型"><a href="#节点的类型" class="headerlink" title="节点的类型"></a>节点的类型</h5><p><code>DOM</code>的最小组成单位叫做节点<code>node</code>。文档的树形结构（<code>DOM</code>树），就是由各种不同类型的节点组成。每个节点可以看作是文档树的一片叶子。<br><code>HTML DOM</code>节点的类型有七种。</p>
<pre><code>* Document：整个文档（DOM树的根节点），nodeType = 9
* DocumentType：文档类型节点（比如&lt;!DOCTYPE html&gt;），nodeType = 10
* Element：网页的各种HTML标签（比如&lt;body&gt;、&lt;a&gt;等），nodeType = 1
* Attribute：网页元素的属性（比如class=&quot;right&quot;），nodeType = 2
* Text：标签之间或标签包含的文本，nodeType = 3
* Comment：注释，nodeType = 8
* DocumentFragment：文档的片段，nodeType = 11
</code></pre><p>这七种节点都属于浏览器原生提供的节点对象的派生对象，具有一些共同的属性和方法。</p>
<hr>
<h4 id="Node-接口"><a href="#Node-接口" class="headerlink" title="Node 接口"></a>Node 接口</h4><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><pre><code>* childNodes 获取子节点（可以是文本、注释、属性） 
* children 获取子标签节点 
* firstChild 返回第一个子节点
* lastChild 返回最后一个子节点     
* nextSibling 返回给定节点的下一个子节点 
* previousSibling 返回给定节点的上一个子节点 
* parentNode （w3c标准）返回给定节点的父节点
* parentElement （只ie支持）返回给定节点的父标签
* ownerDocument 返回元素的根节点文档对象（即 document 对象）
* innerText 里面的文本
* textContent 

* nodeName 节点的名称
    标签节点的 nodeName 是标签名称
    属性节点的 nodeName 是属性名称
    文本节点的 nodeName 永远是 #text
    文档节点的 nodeName 永远是 #document
* nodeType 节点的类型     
* nodeValue 节点的值
    文本节点的 nodeValue 属性包含文本。
    属性节点的 nodeValue 属性包含属性值。
    nodeValue 属性对于文档节点和标签节点是不可用的。

注意：
* nodeName 只有 svg 是小写，其他是大写
* nextSibling 可能获取到文本
* innerText 和 textContent 区别     
</code></pre><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p>如果一个属性是函数，那么这个属性就也叫做方法；换言之，方法是函数属性</p>
<pre><code>* appendChild() 将指定的节点添加到调用该方法的节点的子元素的末尾
* removeChild() 删除指定的子节点并返回
* replaceChild() 交换儿子（将另一个替换这一个，另一个去了内存）
* cloneNode() 复制一个节点
* insertBefore 添加一个节点到一个参照节点之前

* contains() 一个元素是否包含另一个元素
* hasChildNodes() 一个元素是否有儿子

* isEqualNode() 是否相等（看起来一样）  
* isSameNode() 是否相同（真的一样，等价于 ===）

* normalize() 常规化，把不正常的变成正常的

注意：
1.cloneNode() 分为深拷贝和浅拷贝
2.isEqualNode() 和 isSameNode() 区别
</code></pre><hr>
<h4 id="Document-接口（查询接口，因为一般从-document-开始查）"><a href="#Document-接口（查询接口，因为一般从-document-开始查）" class="headerlink" title="Document 接口（查询接口，因为一般从 document 开始查）"></a>Document 接口（查询接口，因为一般从 document 开始查）</h4><h5 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h5><pre><code>* characterSet 字符编码，比如‘UTF-8’
* childElementCount 子元素的数量 
* domain 域名
* links 所有 a 标签
* location 文档的 URL 相关的信息
* onxxxxxxxxx 事件监听，比如 onclick 
* origin 源
* plugins 是否安装插件 
* referrer 引荐
</code></pre><h5 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h5><pre><code>* open() document步骤1.打开
* close() document步骤3.关闭文档
* write() document步骤2.（尽量不用write，用的话避免有延时性）
* writeln() 写一行

* createDocumentFragment() 创建一个 DocumentFragment，主要是用于添加大量节点到文档中时会使用到 
* createElement() 创建元素
* createTextNode() 创建文本节点

* getElementById() 通过 id 获取元素
* getElementsByClassName() 通过 className 获取元素
* getElementsByName() 通过 name 获取元素，它返回一个即时的NodeList 对象。
* getElementsByTagName() 通过 TagName 获取元素，比如 p button
* getSelection() 获取用户选中的文本
* querySelector() 通过选择器，返回一个元素
* querySelectorAll() 通过选择器，返回多个元素组成的数组（一个元素也返回数组） 

注意：
1.获取元素主要使用 querySelector()、querySelectorAll() 
</code></pre><hr>
<h4 id="Element-的接口"><a href="#Element-的接口" class="headerlink" title="Element 的接口"></a>Element 的接口</h4><p><code>DOM API</code>获取的<code>Elements</code>都是伪数组</p>
<h5 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h5><pre><code>* children 子元素列表
* childElementCount 子元素数量
* firstElementChild 第一个子元素
* lastElementChild 最后一个子元素

* classList 类名列表（对象）
* className 类名（字符串）
* id 元素id

* attributes 所有显性属性
* innerHTML 元素内部的HTML标记
* outerHTML 包含元素在内的HTML标记

* clientWidth 内容区 + padding的宽度
* clientHeight 内容区 + padding的高度
* scrollHeight 元素中可以滚动的高度
* scrollWidth 元素中可以滚动的宽度
* scrollTop 元素中的内容已经向上滚出去多少
* scrollLeft 元素中的内容已经向左滚出去多少
</code></pre><h5 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h5><pre><code>* setAttribute() 创建或改变某个新属性
* getAttribute() 通过名称获取属性的值
* getElementsByClassName() 根据元素的 class 属性获取所有元素

* createElement 通过传入指定的一个标签名来创建一个元素
* createTextNode 创建一个文本节点
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Zhao Zhiying</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">Artikel</span>
                </a>
              </div>
            

            

            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhao Zhiying</span>

  
</div>


  <div class="powered-by">Erstellt mit  <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  

  

  

</body>
</html>
